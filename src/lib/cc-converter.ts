import { parseDiffFromFile } from "@pierre/diffs";
import { sanitizeSession } from "./sanitizer";
import type { FileDiffMetadata } from "@pierre/diffs";
import type { JsonValue } from "./types";
import type {
  EditFileEntry,
  MessageEntry,
  MessageImage,
  PlanEntry,
  QuestionnaireEntry,
  SessionEntry,
  SessionSchema,
  SummaryEntry,
  TaskEntry,
  ThinkingEntry,
  TodoListEntry,
  ToolCallEntry,
  ToolOutput,
  WriteFileEntry,
} from "./session-schema";
import type { ExtractedImage } from "./cc-tarball";
import type { CCContentPart, CCLogEntry } from "./cc-schema";
import type { BundleMetadata } from "./bundle-metadata";

// MARK: Parser Types

type PendingSummary = {
  summary: string;
  leafUuid: string;
};

type Question = {
  question: string;
};

// MARK: Helper Functions

const HIDDEN_USER_PREFIXES = [
  "<local-command-caveat>",
  "Caveat: The messages below were generated by the user while running local commands.",
  "<command-name>",
  "<command-message>",
  "<command-args>",
  "<local-command-stdout>",
  "<command-name>/share", // Filter share plugin
  "Implement the following plan:", // Filter plan approval injections
  "[Request interrupted by user for tool use]", // Filter plan interruption
];

function isHiddenUserMessage(text: string): boolean {
  const trimmed = text.trim();
  return HIDDEN_USER_PREFIXES.some((prefix) => trimmed.startsWith(prefix));
}

function isShareRelatedBashCommand(command: string): boolean {
  // Filter share-session.sh invocations
  if (command.includes("share-session.sh")) return true;
  // Filter session file lookup (the ls command for finding session JSONL)
  if (/ls\s+.*\.claude\/projects\/.*\.jsonl/.test(command)) return true;
  return false;
}

// Marker added to share-related messages for reliable detection
const SESSION_SHARE_MARKER = "<!--session-share-->";

function isShareAnnouncementMessage(text: string): boolean {
  return text.includes(SESSION_SHARE_MARKER);
}

function isPlanPath(filePath: string): boolean {
  return filePath.includes("/.claude/plans/");
}

function toDisplayPath(filePath: string, cwd?: string): string {
  if (cwd && filePath.startsWith(cwd + "/")) {
    return filePath.slice(cwd.length + 1);
  }
  return filePath.split("/").pop() || filePath;
}

function extractTextFromPart(part: CCContentPart): string {
  if (typeof part !== "object") return "";

  switch (part.type) {
    case "text":
      return part.text;
    case "code":
      return part.text;
    case "image": {
      const label = part.url || part.path || "";
      return label ? `Image: ${label}` : "Image";
    }
    default:
      return "";
  }
}

function extractTextFromContent(content: Array<CCContentPart> | string | Record<string, unknown> | undefined): string {
  if (typeof content === "string") return content;

  if (Array.isArray(content)) {
    return content
      .map((item) => {
        if (typeof item === "string") return item;
        if ("text" in item && typeof item.text === "string") return item.text;
        if ("content" in item && typeof item.content === "string") return item.content;
        return "";
      })
      .filter(Boolean)
      .join("\n");
  }

  if (content && typeof content === "object") {
    if ("text" in content && typeof content.text === "string") return content.text;
    if ("content" in content && typeof content.content === "string") return content.content;
  }

  return "";
}

function stripToolIds(value: unknown): JsonValue {
  if (Array.isArray(value)) {
    return value.map(stripToolIds);
  }
  if (value && typeof value === "object") {
    const next: Record<string, JsonValue> = {};
    for (const [key, entry] of Object.entries(value)) {
      if (key === "tool_use_id" || key === "tool_id" || key === "toolUseId" || key === "toolId") {
        continue;
      }
      next[key] = stripToolIds(entry);
    }
    return next;
  }
  return value as JsonValue;
}

function toolOutputFromToolResult(
  content: Array<CCContentPart> | string | Record<string, unknown> | undefined
): ToolOutput {
  const text = extractTextFromContent(content);
  if (text) {
    return { type: "text", text };
  }
  if (content && typeof content === "object") {
    return { type: "json", data: stripToolIds(content) };
  }
  return { type: "text", text: "" };
}

function parseQuestionAnswers(text: string): Map<string, string> {
  const map = new Map<string, string>();
  const regex = /"([^"]+)"="([^"]*)"/g;
  let match = regex.exec(text);
  while (match) {
    map.set(match[1], match[2]);
    match = regex.exec(text);
  }
  return map;
}

function extractPlanTitle(planContent: string): string {
  // Look for markdown H1 like "# Plan: Description"
  const h1Match = planContent.match(/^#\s+(.+?)$/m);
  if (h1Match) {
    let title = h1Match[1].trim();
    // Strip "Plan: " prefix if present (case-insensitive)
    title = title.replace(/^Plan:\s*/i, "");
    return title;
  }
  // Fallback: first non-empty line
  const firstLine = planContent.split("\n").find((line) => line.trim());
  let title = firstLine?.trim() || "Plan";
  // Strip "Plan: " prefix if present (case-insensitive)
  title = title.replace(/^Plan:\s*/i, "");
  return title;
}

function normalizeQuestions(input: unknown): Array<{ question: string }> {
  if (!Array.isArray(input)) return [];
  return input
    .filter(
      (item): item is { question: string } =>
        item && typeof item === "object" && "question" in item && typeof item.question === "string"
    )
    .map((item) => ({ question: item.question }));
}

function generateDiff(oldText: string, newText: string, filePath: string): FileDiffMetadata {
  const oldFile = { name: filePath, contents: oldText };
  const newFile = { name: filePath, contents: newText };
  return parseDiffFromFile(oldFile, newFile);
}

// MARK: Main Parser

export function ccSessionToSession(
  jsonlContent: string,
  images?: Map<string, ExtractedImage>,
  bundleMetadata?: BundleMetadata
): SessionSchema {
  const lines = jsonlContent.split(/\r?\n/).filter(Boolean);

  // Session metadata
  let sessionId = "";
  let sessionTitle = "";
  let sessionSlug = "";
  let customTitle: string | undefined;
  let planTitle: string | undefined;
  let planTitleApproved = false;
  let startedAt: string | undefined;
  let cwd: string | undefined;
  let gitBranch: string | undefined;
  let agentVersion: string | undefined;

  // State tracking
  const entries: Array<SessionEntry> = [];
  const toolNameById = new Map<string, string>();
  const pendingToolCalls = new Map<string, ToolCallEntry>();
  const questionsByToolId = new Map<string, Array<Question>>();
  const plansByToolId = new Map<string, string>();
  const pendingSummaries: Array<PendingSummary> = [];
  const taskIds = new Set<string>();
  const seenParentTypeKeys = new Set<string>();
  const skippedUuids = new Set<string>();
  const skippedToolIds = new Set<string>();
  const modelsUsed = new Set<string>();
  // Track rejected plans for "accept and clear context" detection
  const rejectedPlanEntries = new Map<string, PlanEntry>();

  let currentTask: TaskEntry | null = null;

  for (const line of lines) {
    let obj: CCLogEntry;
    try {
      obj = JSON.parse(line) as CCLogEntry;
    } catch {
      continue;
    }

    // Skip duplicate entries - context re-sends
    if (obj.parentUuid) {
      const parentTypeKey = `${obj.parentUuid}:${obj.type}`;

      // Skip if parent was skipped (cascading)
      if (skippedUuids.has(obj.parentUuid)) {
        if (obj.uuid) skippedUuids.add(obj.uuid);
        continue;
      }
      // Skip if same parent+type already processed (sibling duplicate)
      if (seenParentTypeKeys.has(parentTypeKey)) {
        if (obj.uuid) skippedUuids.add(obj.uuid);
        continue;
      }
      seenParentTypeKeys.add(parentTypeKey);
    }

    // Extract session metadata
    if (!sessionId && obj.sessionId) sessionId = obj.sessionId;
    if (obj.cwd && !cwd) cwd = obj.cwd;
    if (!startedAt && obj.timestamp) startedAt = obj.timestamp;
    if (obj.gitBranch && !gitBranch) gitBranch = obj.gitBranch;
    if (obj.version && !agentVersion) agentVersion = obj.version;
    if (obj.slug && !sessionSlug) sessionSlug = obj.slug;

    // Handle custom title entries (user-set via /title command)
    if (obj.type === "custom-title" && obj.customTitle) {
      customTitle = obj.customTitle;
      continue;
    }

    // Handle summary entries - use the last summary (not first) for multi-compaction sessions
    // Filter out generic system titles like "Conversation Cleared" and "Claude Code CLI Session Start"
    if (obj.type === "summary" && obj.summary) {
      const isGenericTitle = obj.summary === "Claude Code CLI Session Start" || obj.summary === "Conversation Cleared";
      if (!isGenericTitle) {
        sessionTitle = obj.summary;
      }
      if (!isGenericTitle && obj.leafUuid) {
        pendingSummaries.push({ summary: obj.summary, leafUuid: obj.leafUuid });
      }
      continue;
    }

    // Skip file-history-snapshot and other non-message types
    if (obj.type !== "user" && obj.type !== "assistant" && obj.type !== "system") {
      continue;
    }

    if (!("message" in obj) || !obj.message) continue;

    // Skip meta messages - they're system injections not shown in Claude Code UI
    if (obj.isMeta) continue;

    // Skip transcript-only messages (e.g., context continuation summaries after compaction)
    if (obj.isVisibleInTranscriptOnly) continue;

    const message = obj.message;

    // Track models used in the session
    if (message.model) {
      modelsUsed.add(message.model);
    }

    const role = message.role || obj.type;
    const content = message.content;
    const messageParts: Array<string> = [];
    const messageImages: Array<MessageImage> = [];

    if (Array.isArray(content)) {
      for (const part of content) {
        // Handle image parts - collect separately
        if (part.type === "image") {
          // Check for inline base64 image first
          if (part.source?.type === "base64" && part.source.data) {
            messageImages.push({
              data: part.source.data,
              mimeType: part.source.media_type || "image/png",
            });
            continue;
          }

          // Otherwise try to find image from bundled files
          const imagePath = part.path || part.url || "";
          if (imagePath && images) {
            const pathWithoutSlash = imagePath.replace(/^\//, "");
            const imageData = images.get(imagePath) || images.get(pathWithoutSlash);
            if (imageData) {
              messageImages.push({
                data: imageData.data.toString("base64"),
                mimeType: imageData.mimeType,
                label: imagePath,
              });
              continue;
            }
          }
          // Fallback: add as text if image not found in bundle
          messageParts.push(imagePath ? `[Image: ${imagePath}]` : "[Image]");
          continue;
        }

        // Handle thinking blocks - create separate ThinkingEntry
        if (part.type === "thinking") {
          const thinkingEntry: ThinkingEntry = {
            type: "thinking",
            content: [part.thinking],
            ...(obj.uuid && { parentId: obj.uuid }),
            ...(message.model && { meta: { model: message.model } }),
          };
          entries.push(thinkingEntry);
          currentTask = null;
          continue;
        }

        // Handle tool_use
        if (part.type === "tool_use") {
          const toolName = part.name;
          if (part.id && toolName) {
            toolNameById.set(part.id, toolName);
          }

          const input = part.input || {};

          // Skip share plugin tool calls
          if (toolName === "Skill" && input.skill === "cc-session-share:share") {
            continue;
          }

          // Handle Task - group by subagent_type into single TaskEntry
          if (toolName === "Task" && input.subagent_type) {
            const taskType = String(input.subagent_type).toLowerCase();
            const description =
              typeof input.description === "string"
                ? input.description.trim()
                : typeof input.prompt === "string"
                  ? input.prompt.split("\n")[0].trim()
                  : "Task";

            // If no current task or different type, create new TaskEntry
            if (!currentTask || currentTask.name !== taskType) {
              currentTask = {
                type: "task",
                name: taskType,
                content: [description],
                ...(obj.uuid && { parentId: obj.uuid }),
              };
              entries.push(currentTask);
            } else {
              // Same type - add to existing
              currentTask.content.push(description);
            }

            if (part.id) taskIds.add(part.id);
            continue;
          }

          currentTask = null;

          // Handle AskUserQuestion
          if (toolName === "AskUserQuestion" && input.questions) {
            const questions = normalizeQuestions(input.questions);
            if (part.id && questions.length > 0) {
              questionsByToolId.set(part.id, questions);
            }
            continue;
          }

          // Handle ExitPlanMode
          if (toolName === "ExitPlanMode" && typeof input.plan === "string") {
            if (part.id) {
              plansByToolId.set(part.id, input.plan);
            }
            continue;
          }

          // Handle TodoWrite
          if (toolName === "TodoWrite" && Array.isArray(input.todos)) {
            const todoEntry: TodoListEntry = {
              type: "todo_list",
              todos: (input.todos as Array<{ content?: string; status?: string }>).map((todo) => ({
                content: String(todo.content ?? ""),
                status: todo.status === "completed" || todo.status === "in_progress" ? todo.status : "pending",
              })),
              ...(obj.uuid && { parentId: obj.uuid }),
            };
            entries.push(todoEntry);
            continue;
          }

          const filePath = typeof input.file_path === "string" ? input.file_path : undefined;

          // Handle Write
          if (toolName === "Write" && filePath) {
            if (isPlanPath(filePath)) continue;

            const displayPath = toDisplayPath(filePath, cwd);
            const fileContent = typeof input.content === "string" ? input.content : "";
            const diffData = generateDiff("", fileContent, displayPath);

            const writeEntry: WriteFileEntry = {
              type: "write_file",
              path: displayPath,
              content: fileContent,
              diffData,
              ...(obj.uuid && { parentId: obj.uuid }),
            };
            entries.push(writeEntry);
            continue;
          }

          // Handle Edit
          if (toolName === "Edit" && filePath) {
            if (isPlanPath(filePath)) continue;

            const displayPath = toDisplayPath(filePath, cwd);
            const oldText = typeof input.old_string === "string" ? input.old_string : "";
            const newText = typeof input.new_string === "string" ? input.new_string : "";
            const diffData = generateDiff(oldText, newText, displayPath);

            const editEntry: EditFileEntry = {
              type: "edit_file",
              path: displayPath,
              oldContent: oldText,
              newContent: newText,
              diffData,
              ...(obj.uuid && { parentId: obj.uuid }),
            };
            entries.push(editEntry);
            continue;
          }

          // Skip share-related Bash commands
          if (toolName === "Bash") {
            const command = typeof input.command === "string" ? input.command : "";
            if (isShareRelatedBashCommand(command)) {
              if (part.id) skippedToolIds.add(part.id);
              continue;
            }
          }

          // Generic tool call - flat structure
          const toolEntry: ToolCallEntry = {
            type: "tool_call",
            name: toolName || "Tool",
            ...(typeof input.description === "string" && { description: input.description }),
            input: input as JsonValue,
            issuedBy: role === "assistant" ? "assistant" : "user",
            ...(obj.uuid && { parentId: obj.uuid }),
          };
          entries.push(toolEntry);
          if (part.id) {
            pendingToolCalls.set(part.id, toolEntry);
          }
          continue;
        }

        // Handle tool_result
        if (part.type === "tool_result") {
          currentTask = null;
          const toolUseId = part.tool_use_id;

          // Skip results for share-related tools that were filtered out
          if (toolUseId && skippedToolIds.has(toolUseId)) {
            skippedToolIds.delete(toolUseId);
            continue;
          }

          // Skip task results (all Task types)
          if (toolUseId && taskIds.has(toolUseId)) {
            taskIds.delete(toolUseId);
            continue;
          }

          const toolName = part.name || toolNameById.get(toolUseId);
          const resultText = extractTextFromContent(part.content);

          // Handle questionnaire results
          if (toolUseId && questionsByToolId.has(toolUseId)) {
            const questions = questionsByToolId.get(toolUseId) || [];
            const answers = parseQuestionAnswers(resultText);
            const combined = questions.map((q) => ({
              question: q.question,
              answer: answers.get(q.question),
            }));

            const questionnaireEntry: QuestionnaireEntry = {
              type: "questionnaire",
              questions: combined,
              ...(obj.uuid && { parentId: obj.uuid }),
            };
            entries.push(questionnaireEntry);
            questionsByToolId.delete(toolUseId);
            continue;
          }

          // Handle plan results (see cc-format.md for detailed documentation)
          if (toolUseId && plansByToolId.has(toolUseId)) {
            const planText = plansByToolId.get(toolUseId)!;
            const title = extractPlanTitle(planText);

            // Track first plan title as fallback
            if (!planTitle) {
              planTitle = title;
            }

            let status: "pending" | "approved" | "rejected";
            let feedback: string | undefined;

            if (/approved your plan/i.test(resultText)) {
              status = "approved";
              // First approved plan takes priority
              if (!planTitleApproved) {
                planTitle = title;
                planTitleApproved = true;
              }
            } else if (/rejected|doesn't want to proceed/i.test(resultText)) {
              status = "rejected";
              // Extract user feedback after "the user said:"
              const feedbackMatch = resultText.match(/the user said:\s*([\s\S]*)/i);
              if (feedbackMatch) {
                feedback = feedbackMatch[1].trim();
              }
            } else {
              status = "pending";
            }

            const planEntry: PlanEntry = {
              type: "plan",
              status,
              title,
              content: planText,
              ...(feedback && { feedback }),
              ...(obj.uuid && { parentId: obj.uuid }),
            };
            entries.push(planEntry);
            plansByToolId.delete(toolUseId);

            // Store rejected plans for "accept and clear context" detection
            if (status === "rejected") {
              rejectedPlanEntries.set(planText, planEntry);
            }
            continue;
          }

          // Skip TodoWrite results
          if (toolName === "TodoWrite") continue;

          // Skip Write/Edit results (already handled)
          if (toolName === "Write" || toolName === "Edit") continue;

          // Match with pending tool call
          if (toolUseId && pendingToolCalls.has(toolUseId)) {
            const callEntry = pendingToolCalls.get(toolUseId)!;
            callEntry.result = toolOutputFromToolResult(part.content);
            pendingToolCalls.delete(toolUseId);
            continue;
          }

          // Orphan tool result - flat structure
          const orphanEntry: ToolCallEntry = {
            type: "tool_call",
            name: toolName || "Tool",
            input: null, // Unknown input for orphan result
            result: toolOutputFromToolResult(part.content),
            ...(obj.uuid && { parentId: obj.uuid }),
          };
          entries.push(orphanEntry);
          continue;
        }

        // Handle other content types - extract as string
        const text = extractTextFromPart(part);
        if (text) {
          currentTask = null;
          messageParts.push(text);
        }
      }
    } else if (typeof content === "string") {
      currentTask = null;
      messageParts.push(content);
    } else if (typeof content === "object") {
      currentTask = null;
      messageParts.push(JSON.stringify(content));
    }

    // Create message entry if we have content or images
    if (messageParts.length > 0 || messageImages.length > 0) {
      const combinedText = messageParts.join("\n");

      // Detect "accept and clear context" pattern for plans
      // When user accepts a plan with "Accept and clear context", Claude Code:
      // 1. Writes a tool result with "rejected/doesn't want to proceed" (which we mark as rejected)
      // 2. Then writes an "Implement the following plan:" user message
      // The presence of this message means the plan was actually approved
      if (role === "user" && messageImages.length === 0) {
        const trimmed = combinedText.trim();
        const implementPrefix = "Implement the following plan:";
        if (trimmed.startsWith(implementPrefix)) {
          const planContent = trimmed.slice(implementPrefix.length).trim();
          // Check if planContent starts with any rejected plan
          // (planContent may have extra text appended by Claude Code)
          for (const [planText, planEntry] of rejectedPlanEntries) {
            if (planContent.startsWith(planText)) {
              planEntry.status = "approved";
              // Update plan title if this is first approved
              if (!planTitleApproved) {
                planTitle = planEntry.title;
                planTitleApproved = true;
              }
              rejectedPlanEntries.delete(planText);
              break;
            }
          }
          continue; // Still hide this synthetic message
        }
      }

      // Skip hidden user messages (but keep if has images)
      if (role === "user" && isHiddenUserMessage(combinedText) && messageImages.length === 0) {
        continue;
      }

      // Skip share announcement messages
      if (role === "assistant" && isShareAnnouncementMessage(combinedText)) {
        continue;
      }

      const messageEntry: MessageEntry = {
        type: "message",
        role: role === "assistant" || role === "user" ? role : "assistant",
        content: messageParts,
        ...(messageImages.length > 0 && { images: messageImages }),
        ...(obj.uuid && { id: obj.uuid }),
        ...(obj.parentUuid && { parentId: obj.parentUuid }),
        ...(obj.timestamp && { createdAt: obj.timestamp }),
        ...(message.model && { meta: { model: message.model } }),
      };
      entries.push(messageEntry);
    }
  }

  // Add any plans that never got a response as pending
  for (const [, planText] of plansByToolId) {
    entries.push({
      type: "plan",
      status: "pending",
      title: extractPlanTitle(planText),
      content: planText,
    });
  }

  // Insert summaries before their leaf messages
  const placedLeafs = new Set<string>();
  for (const pending of pendingSummaries) {
    if (placedLeafs.has(pending.leafUuid)) continue;

    const idx = entries.findIndex((entry) => "id" in entry && entry.id === pending.leafUuid);
    if (idx !== -1) {
      const summaryEntry: SummaryEntry = {
        type: "summary",
        content: pending.summary,
      };
      entries.splice(idx, 0, summaryEntry);
      placedLeafs.add(pending.leafUuid);
    }
  }

  const rawSession: SessionSchema = {
    schemaVersion: "1",
    agent: {
      name: "Claude Code",
      ...(agentVersion && { version: agentVersion }),
    },
    meta: {
      id: sessionId || "unknown",
      // Title priority: customTitle > planTitle (approved or first) > sessionTitle > sessionSlug
      ...(customTitle && { title: customTitle }),
      ...(!customTitle && planTitle && { title: planTitle }),
      ...(!customTitle && !planTitle && sessionTitle && { title: sessionTitle }),
      ...(!customTitle && !planTitle && !sessionTitle && sessionSlug && { title: sessionSlug }),
      ...(startedAt && { startedAt }),
      ...(modelsUsed.size > 0 && { models: Array.from(modelsUsed) }),
      ...((cwd || gitBranch || bundleMetadata?.gitRemote) && {
        environment: {
          ...(cwd && { cwd }),
          ...(bundleMetadata?.gitRemote && { repo: bundleMetadata.gitRemote }),
          ...(gitBranch && { gitBranch }),
        },
      }),
    },
    entries,
  };

  // Sanitize sensitive data (API keys, tokens, passwords, etc.) before returning
  return sanitizeSession(rawSession);
}
